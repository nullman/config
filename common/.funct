#!/usr/bin/env bash
#!       1         2         3         4         5         6         7         8
#!345678901234567890123456789012345678901234567890123456789012345678901234567890
#!==============================================================================
#! .funct
#!
#! Shell Function Definitions
#!
#! Author: Kyle W T Sherman <kylewsherman@gmail.com>
#!==============================================================================
#!
#! cdargs
#!
[ -f "/usr/share/doc/cdargs/examples/cdargs-bash.sh" ] && \
    source "/usr/share/doc/cdargs/examples/cdargs-bash.sh"
#
# helper functions
#
#        config directory
configdir() {
    echo "${HOME}/$([ $(uname -o) == 'Haiku' ] && echo 'haiku-config' || echo 'config')"
}
#
#===============================================================================
# Function Definitions
#===============================================================================

#
# help
#
#        fuh                     funct help
alias fuh="
    cat \${HOME}/.funct \${HOME}/.funct-work 2>/dev/null | \
      grep '^[[:space:]]*#' | grep -v '^[[:space:]]*#!' | sed 's/^[[:space:]]*#//' | \${PAGER}"
#        fuhl                    funct help (long)
alias fuhl="
    cat \${HOME}/.funct \${HOME}/.funct-work 2>/dev/null | \
      grep -v '^[[:space:]]*#!' | grep -v '^[[:space:]]*#  ' | sed s/^[[:space:]]*#// | \${PAGER}"
#        fuhg                    funct help with grep
alias fuhg="
    cat \${HOME}/.funct \${HOME}/.funct-work 2>/dev/null | \
      grep '^[[:space:]]*#' | grep -v '^[[:space:]]*#!' | sed 's/^[[:space:]]*#//' | grep -i"
#        alfuhg                  alias and funct help with grep
alfuhg() {
    for file in ".alias" ".alias-work" ; do
        [ -f "${HOME}/${file}" ] && \
            echo "Aliases (${file}):" && \
            grep '^[[:space:]]*#' "${HOME}/${file}" | grep -v '^[[:space:]]*#!' | sed 's/^[[:space:]]*#//' | grep -i "$1"
    done
    for file in ".funct" ".funct-work" ; do
        [ -f "${HOME}/${file}" ] && \
            echo "Functions (${file}):" && \
            grep '^[[:space:]]*#' "${HOME}/${file}" | grep -v '^[[:space:]]*#!' | sed 's/^[[:space:]]*#//' | grep -i "$1"
    done
}
#!#        alfuhlg                 alias and funct help (long) with grep
#!alfuhlg() {
#!    echo "Aliases:"
#!    grep -v '^[[:space:]]*#!' "${HOME}/.alias" | grep -v '^[[:space:]]*#  ' | sed 's/^[[:space:]]*#//' | grep -i "$1"
#!    echo "Functions:"
#!    grep -v '^[[:space:]]*#!' "${HOME}/.funct" | grep -v '^[[:space:]]*#  ' | sed 's/^[[:space:]]*#//' | grep -i "$1"
#!}
#        alg                     alias grep
alg() {
    sed -n '/^[[:space:]]*#[[:space:]].*'"$1"'/,/"$/p' "${HOME}/.alias"
}
#        fug                     funct grep
fug() {
    sed -n '/^#[[:space:]].*'"$1"'/,/^}$/p' "${HOME}/.funct"
}
#        alfug                   alias and funct grep
alfug() {
    echo "Aliases:"
    sed -n '/^#[[:space:]].*'"$1"'/,/"$/p' "${HOME}/.alias"
    echo "Functions:"
    sed -n '/^#[[:space:]].*'"$1"'/,/^}$/p' "${HOME}/.funct"
}

#
# programming
#
#        pathcmd                 find path of command
pathcmd() {
    if [ $# -lt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: pathcmd COMMAND [PATH...]"
        echo "  COMMAND  command to find"
        echo "  PATH     additional path locations to search"
    else
        cmd="$1"
        shift
        if [ $# -eq 0 ] ; then
            paths="${PATH}"
        else
            for path in "$@" ; do
                paths="${path}:${PATH}"
            done
        fi
        loc=$(echo "${paths}" | sed 's/:/\n/g' | while read -r dir ; do
                  if [ -x "${dir}/${cmd}" ] ; then
                      echo "${dir}/${cmd}"
                  fi
              done)
        [ -n "${loc}" ] && echo "${loc}"
        return $(test -z "${loc}")
    fi
}
#        parentdir               get parent dir
parentdir() {
    if [ $# -gt 2 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: parentdir [DIR]"
        echo "  DIR  directory to get the parent directory of (defaults to current dir)."
    else
        if [ $# -eq 0 ] ; then
            pd="$1"
        else
            pd="$(pwd)"
        fi
        # remove any trailing /'s
        while [ ${#pd} -gt 0 ] && [ "${pd: -1}" == "/" ] ; do
            pd=${pd:0:$((${#pd} - 1))}
        done
        # remove ending characters until a / is reached
        while [ ${#pd} -gt 0 ] && [ "${pd: -1}" != "/" ] ; do
            pd=${pd:0:$((${#pd} - 1))}
        done
        # remove final /
        if [ ${#pd} -gt 1 ] ; then
            pd=${pd:0:$((${#pd} - 1))}
        fi
        echo "${pd}"
    fi
}
#        pstest                  test if a user application is currently running
pstest() {
    if [ $# -lt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: pstest QUERY"
        echo "Test if a user applicaiton containing QUERY is currently running."
        echo "  QUERY  query string to search for"
    else
        pgrep -u "${USER}" -f -i "$1" >/dev/null
    fi
}
#        iscommand               check if executable command is found in the path
iscommand() {
    command -v "$1" >/dev/null 2>&1
}
#        keypress                get a single key press
keypress() {
    # save current tty settings
    ttysettings=$(stty -g)
    # disable canonical mode and local echo
    stty -icanon -echo
    # get key
    key=$(dd bs=1 count=1 2>/dev/null)
    # restore tty settings
    stty "${ttysettings}"
    # return key pressed
    echo "${key}"
}
#        changelog               add a line to a CHANGELOG file in path
changelog() {
    if [ $# -lt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: changelog TEXT..."
    else
        file="CHANGELOG"
        # find changelog file
        dir="$(pwd)"
        while [ ! -e "${dir}/${file}" ] && [ "${dir}" != "/" ] ; do
            dir=$(parentdir "${dir}")
        done
        # if CHANGELOG found, then add comment
        if [ -e "${dir}/${file}" ] ; then
            tmp="${dir}/${file}.tmp$$"
            file="${dir}/${file}"
            if [ -e "${tmp}" ] ; then
                echo "Temp file '${tmp}' exists"
            else
                (
                    echo "$(date '+%Y-%m-%d'): $*" > "${tmp}" && \
                        echo "" >> "${tmp}" && \
                        cat "${file}" >> "${tmp}" && \
                        mv "${tmp}" "${file}"
                ) || echo "Error adding log entry to file '${file}'"
            fi
        else
            echo "File '${file}' not found in path"
        fi
    fi
}

#
# general
#
#!#        cv                      run cdargs and cd to the result
#!cv() {
#!    if [ $# -eq 0 ] ; then
#!        dir=
#!    elif
#!        dir=$(grep "^$1 " "$HOME/.cdargs" | cut -d " " -f 2)
#!    fi
#!    if [ -n "${dir}" ] ; then
#!        cd "${dir}"
#!    else
#!        cdargs "$1" && cd "$(cat "$HOME/.cdargsresult")"
#!    fi
#!}
#        random                  random number
random() {
    if [ $# -eq 0 ] ; then
        echo "$((RANDOM % 10))"
    else
        echo "$((RANDOM % $1))"
    fi
}
#        filename                get real file/dir name of running script
filename() {
    orig="$1"
    dir=$(cd "$(dirname "${orig}")" && pwd)
    file=$(basename "${orig}")
    full="${dir}/${file}"
    realfull=$(realpath "${orig}")
    realdir=$(realpath "${dir}")
    if [ "${full}" != "${realfull}" ] ; then
        echo "Orig:      ${orig}"
        echo "Full:      ${full}"
        echo "Dir:       ${dir}"
        echo "Real Full: ${realfull}"
        echo "Real Dir:  ${realdir}"
        echo "File:      ${file}"
    else
        echo "Orig: ${orig}"
        echo "Full: ${full}"
        echo "Dir:  ${dir}"
        echo "File: ${file}"
    fi
}
#        in-screen               return wether or not terminal is running in screen
in-screen() {
    pid=$(ps -o ppid -p $$ --no-headers)
    term=$(ps -o comm -p ${pid} --no-headers)
    [ "${term}" == "screen" ] && echo "screen" && return 0
    return 1
}
#        term-name               return current terminal name or screen
term-name() {
    term="unknown"
    screen="$(in-screen)"
    cmd=$(ps -o comm -p $$ --no-headers)
    case "${cmd}" in
        bash|tsh|csh|zsh|fish) term="${cmd}" ;;
    esac
    if [ -n "${screen}" ] ; then
        echo "${screen}|${term}"
    else
        echo "${term}"
    fi
}
#        psg                     ps with grep
psg() {
    pids=$(pgrep -f -i "$1" | tr '\n' ',' | sed 's/,$//')
    [ -n "${pids}" ] && ps -o pid,ppid,user,args -p ${pids}
}
#        psgg                    ps with grep (with more fields)
psgg() {
    pids=$(pgrep -f -i "$1" | tr '\n' ',' | sed 's/,$//')
    [ -n "${pids}" ] && ps -o pid,ppid,user,pcpu,pmem,size,vsize,args -p ${pids}
}
#        grepper                 fancy grep
grepper() {
    grep -iIHrn --color=always "$1" . | ${PAGER}
}
#        nsg                     netstat -a with grep
nsg() {
    netstat -a | grep -i "$1" | ${PAGER}
}
#        host-ping               ping to resolve name to ip address
host-ping() {
    ping -c 1 "$1" | grep PING | sed 's/^[^(]*(\([^)]*\)).*$/\1/'
}
#        fnd                     find files
fnd() {
    if [ $# -lt 1 ] || [ $# -gt 2 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: fnd QUERY [DIR]"
    else
        query="$1"
        shift
        if [ $# -eq 0 ] ; then
            dir="."
        else
            dir="$1"
        fi
        find "${dir}" -iname "*${query}*" -print
    fi
}
#        fndg                    find files with grep
fndg() {
    if [ $# -lt 2 ] || [ $# -gt 3 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: fndg QUERY GREP [DIR]"
    else
        query="$1"
        shift
        grep="$1"
        shift
        if [ $# -eq 0 ] ; then
            dir="."
        else
            dir="$1"
        fi
        find "${dir}" -iname "*${query}*" -print | grep "${grep}"
    fi
}
#        wcdir                   word (line) count a directory
wcdir() {
    if [ $# -gt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: wcdir [DIR]"
    else
        if [ $# -eq 0 ] ; then
            dir="."
        else
            dir="$1"
        fi
        $(pathcmd ls) -1 "${dir}" | wc -l
    fi
}
#        dtloop                  datetime stamp looping
dtloop() {
    if [ $# -gt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: dtloop [DELAY]"
        echo "Output the current date-time in a loop."
        echo "  DELAY  time between outputs (defaults to 5s)"
    else
        if [ $# -eq 0 ] ; then
            delay="5s"
        else
            delay="$1"
        fi
        while true ; do
            date '+%Y-%m-%d %H:%M:%S'
            sleep "${delay}"
        done
    fi
}
#        kmg                     convert bytes into KB, MB, GB, or TB as appropriate
kmg() {
    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: kmg NUM"
    else
        k=$(echo "scale=2; $1 / 1024" | bc)
        kf=$(echo "$1 / 1024" | bc)
        m=$(echo "scale=2; ${k} / 1024" | bc)
        mf=$(echo "${k} / 1024" | bc)
        g=$(echo "scale=2; ${m} / 1024" | bc)
        gf=$(echo "${m} / 1024" | bc)
        t=$(echo "scale=2; ${g} / 1024" | bc)
        tf=$(echo "${g} / 1024" | bc)
        if [ ${kf} -lt 1 ] ; then
            echo "$1B"
        elif [ ${mf} -lt 1 ] ; then
            echo "${k}KB"
        elif [ ${gf} -lt 1 ] ; then
            echo "${m}MB"
        elif [ ${tf} -lt 1 ] ; then
            echo "${g}GB"
        else
            echo "${t}TB"
        fi
    fi
}
#        java-vnc                java vncviewer
java-vnc() {
    java VncViewer HOST $1 PORT 5900
}
#        prompt                  execute with prompt
prompt() {
    echo "$@" | fmt
    echo -n "Execute command line? [Yn] "
    read -r a
    case "${a}" in
        y|Y|"") ("$@") ;;
    esac
}
#        mail-file               mail a file (uuencoded)
mail-file() {
    if [ $# -lt 3 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: mail-file FILE SUBJECT ADDRESS..."
    else
        file="$1"
        shift
        sub="$1"
        shift
        (uuencode "${file}" "${file}") | mailx -s "${sub}" "$@"
    fi
}
#        speak-url               speak a url
speak-url() {
    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: speak-url URL"
    else
        lynx --dump "$1" |
            sed 's/\[.*\]//g ; s/[^0-9a-zA-Z \?\,\.\;\:]//g ; /^References$/,$d' |
            festival --tts
    fi
}
#        generate-qrc            generate QR code from given URL, text, or VCARD
generate-qrc() {
    printf "$@" | curl -F-=\<- qrenco.de
}
#        colors                  show terminal colors
colors() {
    local fgc bgc vals seq0

    printf "Color escapes are %s\n" '\e[VALUE;...;VALUEm'
    printf "Values 30..37 are \e[33mforeground colors\e[m\n"
    printf "Values 40..47 are \e[43mbackground colors\e[m\n"
    printf "Value  1 gives a  \e[1mbold-faced look\e[m\n\n"

    # foreground colors
    for fgc in {30..37} ; do
        # background colors
        for bgc in {40..47} ; do
            fgc=${fgc#37} # white
            bgc=${bgc#40} # black

            vals="${fgc:+$fgc;}${bgc}"
            vals=${vals%%;}

            seq0="${vals:+\e[${vals}m}"
            printf "  %-9s" "${seq0:-(default)}"
            printf " ${seq0}TEXT\e[m"
            printf " \e[${vals:+${vals+$vals;}}1mBOLD\e[m"
        done
        echo; echo
    done
}

#        distribution            show linux distribution
distribution () {
    # source: https://github.com/ChrisTitusTech/mybash/blob/main/.bashrc
    local dist="unknown"

    if [ -r "/etc/os-release" ] ; then
        source "/etc/os-release"
        case ${ID} in
            arch|manjaro)
                dist="arch"
                ;;
            debian|ubuntu)
                dist="debian"
                ;;
            gentoo)
                dist="gentoo"
                ;;
            guix)
                dist="guix"
                ;;
            nixos)
                dist="nixos"
                ;;
            qubes)
                dist="qubes"
                ;;
            rhel|fedora|centos)
                dist="redhat"
                ;;
            slackware)
                dist="slackware"
                ;;
            sles|opensuse*)
                dist="suse"
                ;;
            *)
                if [ -n "${ID_LIKE}" ] ; then
                    case ${ID_LIKE} in
                        *arch*|*manjaro*)
                            dist="arch"
                            ;;
                        *debian*|*ubuntu*)
                            dist="debian"
                            ;;
                        *gentoo*)
                            dist="gentoo"
                            ;;
                        *guix*)
                            dist="guix"
                            ;;
                        *nixos*)
                            dist="nixos"
                            ;;
                        *qubes*)
                            dist="qubes"
                            ;;
                        *rhel*|*fedora*|*centos*)
                            dist="redhat"
                            ;;
                        *slackware*)
                            dist="slackware"
                            ;;
                        *sles*|*opensuse*)
                            dist="suse"
                            ;;
                    esac
                fi
                ;;
        esac
    fi

    echo ${dist}
}

#        ver                     show linux version
ver() {
    # source: https://github.com/ChrisTitusTech/mybash/blob/main/.bashrc
    local dist
    dist="$(distribution)"

    case ${dist} in
        "arch")
            cat "/etc/os-release"
            ;;
        "debian")
            lsb_release -a
            ;;
        "gentoo")
            cat "/etc/gentoo-release"
            ;;
        "nixos")
            sed -n "s/^PRETTY_NAME=\"\(.*\)\"/\1/p" "/etc/os-release"
            ;;
        "redhat")
            if [ -s "/etc/redhat-release" ] ; then
                cat "/etc/redhat-release"
            else
                cat "/etc/issue"
            fi
            uname -a
            ;;
        "slackware")
            cat "/etc/slackware-version"
            ;;
        "suse")
            cat "/etc/SuSE-release"
            ;;
        *)
            if [ -s "/etc/issue" ] ; then
                cat "/etc/issue"
            else
                echo "Error: Unknown distribution"
                exit 1
            fi
            ;;
    esac
}

#        colorscript-slideshow   run all colorscript scripts
colorscript-slideshow() {
    once=1
    random=0
    delay=2

    list=($(colorscript --list | tail -n +2))
    length=$((${#list[@]} - 1)) # there is a bug where the last script does not work
    bad=(32 33 34)

    _usage() {
        cat <<EOF
Usage: colorscript-slideshow [OPTIONS]
Run colorscript scripts.
OPTIONS:
  -o, --once        run each script one time
  -c, --continuous  run all scripts in a continuous loop
  -r, --random      run scripts randomly
  -d, --delay       time to pause between scripts (defaults to 2s)
EOF
    }

    _show() {
        local num="$1"
        # ignore scripts that never end
        if [ ! " ${bad[*]} " =~ " ${num} " ] ; then
            clear
            echo
            echo "${list[${num}]}"
            echo
            colorscript exec "${num}"
            sleep "${delay}"
        fi
    }

    while [ $# -gt 0 ] ; do
        opt="$1"

        case "${opt}" in
            -o|--once)
                once=1
                shift
                ;;
            -c|--continuous)
                once=0
                shift
                ;;
            -r|--random)
                random=1
                shift
                ;;
            -d|--delay)
                delay="$2"
                shift
                shift
                ;;
            -h|--help)
                _usage
                shift
                return 0
                ;;
            *)
                printf "colorscript-slideshow: unrecognized option '%s'\n\n" "$1"
                _usage colorscript-slideshow
                return 1
                ;;
        esac
    done

    if [ ${random} -eq 1 ] ; then
        while true ; do
            _show $((RANDOM % length + 1))
        done
    elif [ ${once} -eq 1 ] ; then
        for x in $(seq ${length}) ; do _show "${x}" ; done
    else
        while true ; do
            for x in $(seq ${length}) ; do _show "${x}" ; done
        done
    fi
}
#        ansi                    display an ANSI text graphic file at 1200 baud
ansi() {
    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: ansi FILE"
        echo "Display an ANSI text graphic file at 1200 baud."
    else
        iconv -f 437 "$1" | pv --quiet --rate-limit 1200
    fi
}
#        ansi-slideshow          display a slideshow of all ANSI text graphic files in given directory
ansi-slideshow() {
    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: ansi-slideshow DIR"
        echo "Display a slideshow of all ANSI text graphic files in given directory."
    else
        find "$1" -iname "*.ANS" -print | sort --random-sort | while read -r file ; do
            iconv -f 437 "${file}" | pv --quiet --rate-limit 1200
            sleep 10
        done
    fi
}
#        wordle-match            list wordle words matching given pattern
wordle-match() {
    if [ $# -lt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: wordle-match LENGTH EXCLUDE INCLUDE MATCH"
        echo "Search for Wordle words matching given pattern."
        echo "  LENGTH   length of words to consider"
        echo "  EXCLUDE  letters to exclude"
        echo "  INCLUDE  letters to include"
        echo "  MATCH    letters and positions to match (regexp)"
        echo "Example: wordle-match 5 abc def ...gh"
    else
        cmd="cat ~/doc/information/words.txt | grep '^.\{$1\}$' | tr 'A-Z' 'a-z'"
        if [ $# -gt 1 ] ; then
            cmd="${cmd} | grep --color=never -v '[$2]'"
        fi
        if [ $# -gt 2 ] ; then
            for x in $(echo "$3" | grep -o '.') ; do
                cmd="${cmd} | grep --color=never '${x}'"
            done
        fi
        if [ $# -gt 3 ] ; then
            cmd="${cmd} | grep --color=never '$4'"
        fi
        #echo "${cmd}"
        eval "${cmd}"
    fi
}
#        play-youtube-desktop    play a youtube video on the desktop background
play-youtube-desktop() {
    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: play-youtube-desktop VIDEOID"
        echo "Play YouTube video on desktop background."
    else
        xwinwrap -ni -g "$(xwininfo -root | grep geometry | cut -c 13-)" \
                 -s -st -sp -b -nf -ov -- mpv --profile=wallpaper \
                 -wid WID "https://youtu.be/$1" loop 0
    fi
}

#
# conversion
#
#        dos-to-linux            convert a dos text file CR+LF to linux LF format
dos-to-linux() {
    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: dos-to-linux FILE"
        echo "Convert FILE from DOS format to Linux format."
        echo "Convert multiple files using something like:"
        echo "  ls -1 | while read -r f ; do dos-to-linux \$f ; done"
    else
        sed -i 's/\r$//' "$1"
    fi
}
#        linux-to-dos            convert a linux text file LF to dos CR+LF format
linux-to-dos() {
    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: linux-to-dos FILE"
        echo "Convert FILE from Linux format to DOS format."
        echo "Convert multiple files using something like:"
        echo "  ls -1 | while read -r f ; do linux-to-dos \$f ; done"
    else
        sed -i 's/$/\r/' "$1"
    fi
}
#        lower-dir               convert dir to lowercase
lower-dir() {
    echo "You are about to recursively convert the contents of the current directory"
    echo "'$(pwd)' to lowercase,"
    echo -n "Do you wish to proceed? [yN] "
    read -r a
    case "${a}" in
        y|Y)
            find . -depth -type d | while read -r infile ; do
                outfile=$(echo "${infile}" | tr '[:upper:]' '[:lower:]')
                mv -fv "${infile}" "${outfile}"
            done
            find . -depth -type f | while read -r infile ; do
                outfile=$(echo "${infile}" | tr '[:upper:]' '[:lower:]')
                mv -fv "${infile}" "${outfile}"
            done
            ;;
    esac
}
#        upper-dir                convert dir to uppercase
upper-dir() {
    echo "You are about to recursively convert the contents of the current directory"
    echo "'$(pwd)' to uppercase,"
    echo -n "Do you wish to proceed? [yN] "
    read -r a
    case "${a}" in
        y|Y)
            find . -depth -type d | while read -r infile ; do
                outfile=$(echo "${infile}" | tr '[:lower:]' '[:upper:]')
                mv -fv "${infile}" "${outfile}"
            done
            find . -depth -type f | while read -r infile ; do
                outfile=$(echo "${infile}" | tr '[:lower:]' '[:upper:]')
                mv -fv "${infile}" "${outfile}"
            done
            ;;
    esac
}
#        uncompress-dir-tree     uncompress all zip files in given directory tree
uncompress-dir-tree() {
    echo "You are about to uncompress the contents of the current directory"
    echo "'$(pwd)', and all of its children, and delete the original files."
    echo "Only .zip files are considered."
    echo -n "Do you wish to proceed? [yN] "
    read -r a
    case "${a}" in
        y|Y)
            find . -iname "*.zip" -print | while read -r file ; do
                echo "${file}"
                dir="${file:0:-4}"
                mkdir "${dir}" && unzip -n -d "${dir}" "${file}" && rm "${file}"
            done
            ;;
    esac
}
#        convert-7z-to-zip-dir-tree  convert all 7z files in given directory tree to zip
convert-7z-to-zip-dir-tree() {
    echo "You are about to convert the 7z files found in the current directory"
    echo "'$(pwd)', and all of its children, to zip files."
    echo "Only .7z files are considered."
    echo -n "Do you wish to proceed? [yN] "
    read -r a
    case "${a}" in
        y|Y)
            tmpdir="$(mktemp -d)"
            find . -iname "*.7z" -print | while read -r file ; do
                echo "${file}"
                base=$(basename "${file}")
                new="${base:0:-3}.zip"
                cp "${file}" "${tmpdir}/${base}" && pushd "${tmpdir}" && \
                    7z x "${base}" && rm "${base}" && zip -r "${new}" ./* && \
                    popd && cp "${tmpdir}/${new}" "./${new}" && \
                    rm "${file}"
            done
            rm -rf "${tmpdir}"
            ;;
    esac
}
#        lns-dir                 make links to every file in a directory
lns-dir() {
    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: lns-dir DIR"
    else
        $(pathcmd ls) -1 "$1" | while read -r file ; do
            ln -s "$1/${file}" "${file}"
        done
    fi
}
#        flatten-dir             flatten directory
flatten-dir() {
    if [ $# -ne 2 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: flatten-dir INDIR OUTDIR"
    else
        indir="$1"
        outdir="$2"
        if [ ! -d "${indir}" ] ; then
            echo "Error finding '${indir}' directory"
        elif [ ! -d "${outdir}" ] ; then
            echo "Error finding '${outdir}' directory"
        else
            outdir=$(cd "${outdir}" && pwd)
            pushd "${indir}" || return
            find . -type f | while read -r file ; do
                output=$(echo "${file}" | cut -c 3- | tr '/' '_')
                output="${outdir}/${output}"
                cp -u "${file}" "${output}"
            done
            popd || return
        fi
    fi
}
#        sed-dir                 apply sed to all files in directory
sed-dir() {
    if [ $# -lt 1 ] || [ $# -gt 2 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: sed-dir SCRIPT [DIR]"
        echo "Apply sed SCRIPT to all files in current directory or DIR."
    else
        script="$1"
        shift
        if [ $# -eq 0 ] ; then
            dir="."
        else
            dir="$1"
        fi
        dir=$(cd "${dir}" && pwd)
        echo "You are about to apply SED script '$1'"
        echo "to all files in directory '${dir}'."
        echo -n "Do you wish to proceed? [yN] "
        read -r a
        case "${a}" in
            y|Y)
                (
                    cd "${dir}" && \
                        find . -mindepth 1 -maxdepth 1 -type f | while read -r file ; do
                            echo "${file}"
                            sed -i "${script}" "${file}"
                        done
                )
                ;;
        esac
    fi
}
#
# video conversion
#
#        convert-video-to-mp4      convert all videos in current directory to mp4 videos
convert-video-to-mp4() {
    if [ $# -lt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: convert-video-to-mp4 FILE..."
        echo "Convert all FILEs to mp4 video."
    else
        files=("$@")
        for infile in "${files[@]}" ; do
            outfile=$(echo "${infile}" | sed 's/\..*$/.mp4/')
            echo "${infile} -> ${outfile}"
            ffmpeg -n -i "${infile}" \
                   -c:v libx264 \
                   -c:a aac \
                   "${outfile}"
        done
    fi
}
#        convert-video-to-mp3    convert video to audio mp3
convert-video-to-mp3() {
    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: convert-video-to-mp3 FILE"
        echo "Convert a video to an audio only mp3 with 192K bitrate."
    else
        infile="$1"
        outfile=$(echo "${infile}" | sed 's/\..*$/.mp3/')
        ffmpeg -n -i "${infile}" -b:a 192k -vn "${outfile}"
    fi
}
#        convert-video-to-720p   convert blu-ray 1080p video to 720p
convert-video-to-720p() {
    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: convert-video-to-720p FILE"
        echo "Convert a blu-ray 1080p video to 720p."
    else
        infile="$1"
        outfile=$(echo "${infile}" | sed 's/\..*$/-720p.mp4/')
        ffmpeg -n -i "${infile}" \
               -c:v libx264 -preset veryslow -tune film -crf 22 -vf scale=-2:720 \
               -c:a aac \
               "${outfile}"
               #-b:a 192k \
    fi
}

#
# compression
#
#        comp                    compress (tar then gzip)
comp() {
    if [ $# -lt 2 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: comp ARCHIVE FILE..."
    else
        arch="$1"
        shift
        tar cvfz "${arch}" "$@"
    fi
}
#        uncomp                  uncompress (ungzip then untar)
uncomp() {
    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: uncomp FILE"
    else
        file="$1"
        if [ -f "${file}" ] ; then
            case "${file}" in
                *.tar.bz2)   tar xjf "${file}"    ;;
                *.tar.gz)    tar xzf "${file}"    ;;
                *.tar.xz)    tar xJf "${file}"    ;;
                *.tar.zst)   unzstd "${file}"     ;;
                *.bz2)       bunzip2 "${file}"    ;;
                *.rar)       unrar x "${file}"    ;;
                *.gz)        gunzip "${file}"     ;;
                *.xz)        unxz "${file}"       ;;
                *.zst)       unzstd "${file}"     ;;
                *.tar)       tar xf "${file}"     ;;
                *.tbz2)      tar xjf "${file}"    ;;
                *.tgz)       tar xzf "${file}"    ;;
                *.zip)       unzip "${file}"      ;;
                *.Z)         uncompress "${file}" ;;
                *.7z)        7z x "${file}"       ;;
                *.deb)       ar x "${file}"       ;;
                *)           echo "'${file}' cannot be uncompressed by uncomp" ;;
            esac
        else
            echo "'${file}' is not a valid file"
        fi
    fi
}
#        unparrar                un-par-rar (par2 then unrar)
unparrar() {
    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: unparrar FILE"
    else
        par2 r "$1."*".PAR2"
        unrar e "$1.part"*".rar"
    fi
}

#
# encryption
#
#        encrypt                 encrypt file
encrypt() {
    if [ $# -lt 2 ] || [ $# -gt 3 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: encrypt INFILE OUTFILE [PASSWORD]"
    else
        infile="$1"
        shift
        outfile="$1"
        shift
        if [ $# -eq 0 ] ; then
            read -r -s -p 'Password: ' pw
        else
            pw="$1"
        fi
        openssl enc -e -aes-256-cbc -md sha512 -pbkdf2 -base64 -in "${infile}" -out "${outfile}" -pass "pass:${pw}"
    fi
}
#        decrypt                 decrypt file
decrypt() {
    if [ $# -lt 2 ] || [ $# -gt 3 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: decrypt INFILE OUTFILE [PASSWORD]"
    else
        infile="$1"
        shift
        outfile="$1"
        shift
        if [ $# -eq 0 ] ; then
            read -r -s -p 'Password: ' pw
        else
            pw="$1"
        fi
        openssl enc -d -aes-256-cbc -md sha512 -pbkdf2 -base64 -in "${infile}" -out "${outfile}" -pass "pass:${pw}"
    fi
}

#
# process kill
#
#        ktg                     kill -SIGTERM (friendly) with grep
ktg() {
    pkill -SIGTERM -f -i "$1"
}
#        kkg                     kill -SIGKILL (forced) with grep
kkg() {
    pkill -SIGTERM -f -i "$1"
    sleep 1
    pkill -SIGKILL -f -i "$1"
}
#        khg                     kill -HUP (restart) with grep
khg() {
    pkill -SIGHUP -f -i "$1"
}
#        psk                     process kill (SIGTERM) with fzf selection
psk() {
    ps -U "${USER}" -o pid,command | grep -i "$1" | fzf --multi | awk '{print $1}' | xargs kill -SIGTERM
}
#        pskk                    process kill (SIGKILL) with fzf selection
pskk() {
    ps -U "${USER}" -o pid,command | grep -i "$1" | fzf --multi | awk '{print $1}' | xargs kill -SIGKILL
}

#
# admin tools
#
#        show-mem                show task memory usage
show-mem() {
    # TODO: need to fix this
    ps -aux | sort +5n
}
#        show-ip                 show configured IP address
show-ip() {
    ifconfig | awk '/inet/{print $2}' | awk -F : '//{print $2}' | grep -v "^$"
}
#        show-port               show active network ports
show-port() {
    lsof | grep 'COMMAND    PID' && lsof | grep 'inet'
}
#        show-stats               show system statistics
show-stats() {
    echo "Server Name: $(uname -n)"
    echo "Server IP:   $(net lookup $(uname -n))"
    echo "Logins:      $(who | wc | awk '{print $1}')"
    echo "Users:       $(who | sort | awk '{print $1}' | uniq | wc | awk '{print $1}')"
    echo "Load:       $(uptime | cut -d, -f4 | cut -d: -f2)"
}
#        fsck-shutdown            shutdown computer and fsck all drives on next bootup
fsck-shutdown() {

    echo "You are about to reboot the computer and have it fsck the root drive."
    echo -n "Do you wish to proceed? [yN] "
    read -r a
    case "${a}" in
        y|Y)
            sudo touch /forcefsck && sudo reboot
            ;;
    esac
}
#        delete-broken-symlinks  find and delete broken symlinks in given directory
delete-broken-symlinks() {
    opts="-maxdepth 0"
    dir=""

    _usage() {
        cat <<EOF
Usage: delete-broken-symlinks DIR [OPTIONS]
Delete broken symlinks in DIR.
OPTIONS:
  DIR              directory to search in
  -h, --help       show this help
  -r, --recursive  recurse into sub-directories
EOF
    }

    while [ $# -gt 0 ] ; do
        opt="$1"
        case "${opt}" in
            -r|--recursive)
                opts=""
                shift
                ;;
            -h|--help)
                _usage
                return 0
                ;;
            *)
                if [ -z "${dir}" ] ; then
                    dir="${opt}"
                    shift
                else
                    _usage
                    return 1
                fi
                ;;
        esac
    done

    if [ -z "${dir}" ] ; then
        _usage
        return 1
    fi

    echo "Deleting broken symlinks in '${dir}'..."
    cmd="find -L \"${dir}\" ${opts} -name . -o -type l -print"
    eval "${cmd}" | while read -r file ; do
        if [ -L "${file}" ] && [ ! -e "${file}" ] ; then
            echo "  ${file}"
            rm "${file}"
        fi
    done
}
#        longevity               clean out old files
longevity() {
    if [ $# -ne 3 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: longevity DIR PATTERN DAYS"
        echo "Delete all files matching PATTERN in DIR older than DAYS."
        echo "  DIR      top level directory to search"
        echo "  PATTERN  file pattern to match on"
        echo "  DAYS     number of days to keep"
    else
        dir="$1"
        pattern="$2"
        days="$3"
        echo "You are about to delete all files matching pattern '${pattern}'"
        echo "in ${dir} that are older than ${days} days."
        echo -n "Do you wish to proceed? [yN] "
        read -r a
        case "${a}" in
            y|Y)
                find "${dir}" -mtime +${days} -type f -iname "${pattern}" -exec rm {} \;
                ;;
        esac
    fi
}
#        make-terminfo-trs100    make terminfo file for trs-80 model 100
make-terminfo-trs100() {
    tmpfile="$(mktemp)"
    cat <<EOF > "${tmpfile}"
trs100|Radio Shack Model 100:\
:am:bs:xt:\
:co#40:li#8:\
:al=\EL:bl=^G:cd=\EJ:ce=\EK:cl=\EE:cm=\EY%+ %+ :\
:cr=^M:dl=\EM:do=^J:ho=\EH:kb=^H:kd=^_:kl=^]:kr=^\:\
:ku=^^:le=^H:nd=34:se=\Eq:sf=^J:so=\Ep:up=\EA:\
:ve=\EP:vi=\EQ:
EOF
    sudo tic "${tmpfile}"
    rm "${tmpfile}"
}

#
# ssh
#
#        ssh-key-copy            copy ssh key authorization to remote server
ssh-key-copy() {
    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: ssh-key-copy [USER@]SERVER"
    else
        ssh "$1" '[ ! -d .ssh ] && mkdir -p .ssh && chmod 700 .ssh'
        find "${HOME}/.ssh/" -name "*.pub" | while read -r file ; do
            cat "${file}" | ssh "$1" 'cat >> .ssh/authorized_keys ; \
                chmod 600 .ssh/authorized_keys'
        done
    fi
}
#!# this version does not work on macos
#!ssh-key-copy() {
#!    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
#!        echo "Usage: ssh-key-copy [USER@]SERVER"
#!    else
#!        ssh-copy-id -i "${HOME}/.ssh/id_dsa.pub" "$1"
#!        ssh-copy-id -i "${HOME}/.ssh/id_rsa.pub" "$1"
#!    fi
#!}
#        ssh-urxvt-copy          copy urxvt terminfo data to remote server
ssh-urxvt-copy() {
    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: ssh-urxvt-copy [USER@]SERVER"
    else
        infocmp urxvt | \
            ssh "$1" 'cat > /tmp/terminfo && mkdir -p .terminfo && \
              tic /tmp/terminfo && rm -f /tmp/terminfo'
    fi
}

#
# disk
#
#        hd-fast                 speed up hard disk access
hd-fast() {
    hdparm -c1 -d1 -k1 "/dev/$1"
}
#        hdi                     hard disk info
hdi() {
    hdparm -i "/dev/$1"
}
#        hdv                     hard disk settings
hdv() {
    hdparm -v "/dev/$1"
}
#        hdt                     hard disk speed test
hdt() {
    hdparm -tT "/dev/$1"
}
#        disk-uuid               print uuids for system disks
disk-uuid() {
    output=$(
        (
            unset extendeds
            grep -v '[0-9]$' /proc/partitions | awk '{print $4}' | grep '^[sh]d' | while read -r extended ; do
                id=$(parted "/dev/${extended}" print | grep extended | awk '{print $1}' 2>/dev/null)
                if [ -n "${id}" ] ; then
                    echo "${extended}${id}_EXT_none_none"
                    extendeds="${extendeds} ${extended}${id}"
                fi
            done
            grep '[0-9]' /proc/swaps | awk '{print $1}' | while read -r swap ; do
                drive=$(echo "${swap}" | cut -d/ -f 3)
                uuid=$(vol_id -u "${swap}" 2>/dev/null)
                echo "${drive}_SWAP_none_${uuid}"
            done
            grep '[0-9]$' /proc/partitions | awk '{print $4}' | while read -r partition ; do
                for extended in ${extendeds} ; do
                    [ "${partition}" == "${extended}" ] && unset partition
                done
                if [ -n "${partition}" ] ; then
                    mount=$(df -l -x tmpfs -x usbfs | grep -w "${partition}" | awk '{print $6}')
                    uuid=$(vol_id -u "/dev/${partition}" 2>/dev/null)
                    [ -n "${mount}" ] && echo "${partition}_REG_${mount}_${uuid}"
                fi
            done
        ) | sort)
    (
        echo "PARTITION TYPE MOUNT UUID"
        for line in ${output} ; do
            echo "${line}" | sed 's/_/ /g'
        done
    ) | column --table
}

#
# web
#
#        web-search              google search
web-search() {
    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: web-search QUERY"
    else
        web "http://www.google.com/search?num=50&q=$1"
    fi
}
#        leach                   leach files from the web
leach() {
    if [ $# -lt 1 ] || [ $# -gt 2 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: leach URL [PATTERN[,...]]"
    else
        url="$1"
        shift
        if [ $# -eq 0 ] ; then
            pattern=
        else
            pattern="-A $1"
        fi
        wget -r -p -L -nc -nH -np -q "${url}" "${pattern}"
    fi
}
#        upload-0x0              upload a file (or pipe) to 0x0.st
upload-0x0() {
    [ -f "$1" ] && op="cat"
    "${op:-echo}" "${1:-$(cat -)}" | curl -F file='@-' "https://0x0.st"
}

#
# ssl certificates
#
#        make-cert               make ssl certificate
make-cert() {
    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: make-cert NAME"
    else
        name="$1"
        openssl req -new > "${name}.cert.csr"
        openssl rsa -in privkey.pem -out "${name}.cert.key"
        openssl x509 -in "${name}.cert.csr" -out "${name}.cert.cert" -req -signkey "${name}.cert.key" -days 365
    fi
}

#
# arch
#
#!#        pmi                     pamac install or build
#!#
#!pmi() {
#!    if [ $# -ne 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
#!        echo "Usage: pmi PACKAGE"
#!    else
#!        pamac install --no-confirm "$1" || pamac build --no-confirm "$1"
#!    fi
#!}
#        yasg                    yay search with grep
yasg() {
    if [ $# -lt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: yasg SEARCH GREP"
    else
        s="$1"
        shift
        yay -Ss "${s}" 2>/dev/null | sed -n ":a ; { N ; s/\n */ | / ; p ; d ; ba }" | grep -i "$*"
    fi
}
#        yass                    yay specific search
yass() {
    if [ $# -lt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: yass SEARCH"
    else
        yay -Ss "$*" 2>/dev/null | sed -n ":a ; /^[a-z]*\/$* / { N ; s/\n */ | / ; p ; d ; ba }"
    fi
}
#        yasi                    yay search installed packages
yasi() {
    if [ $# -lt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: yasi SEARCH"
    else
        yay -Ss "$*" 2>/dev/null | sed -n ":a ; { N ; s/\n */ | / ; p ; d ; ba }" | grep " (Installed"
    fi
}
#        yasis                   yay specific search installed packages
yasis() {
    if [ $# -lt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: yasis SEARCH"
    else
        yay -Ss "$*" 2>/dev/null | sed -n ":a ; /^[a-z]*\/$* / { N ; s/\n */ | / ; p ; d ; ba }" | grep " (Installed"
    fi
}

#
# debian
#
#        acsg                    apt-cache search with grep
acsg() {
    if [ $# -lt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: acsg QUERY"
    else
        apt-cache search "$1" | grep -i "^$1"
    fi
}

if [ "$(distribution)" == "guix" ] ; then
#
# guix
#
#        ,                       temporarily install and run program
function , {
    pkg_ver="$(set -o pipefail; guix locate "$1" | grep /bin/ | head -1 | cut -f1)"
    pkg="$(echo ${pkg_ver} | cut -d@ -f1)"
    test -n "$pkg" && guix shell "$pkg" -- "$@"
}
fi

#
# nixos
#
#        nixs                    nix search
nixs() {
    if [ $# -lt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: nixs SEARCH"
    else
        s="$1"
        shift
        nix search --quiet nixpkgs "${s}" 2>/dev/null | grep -v "warning:"
    fi
}
#        nixss                   nix specific search
nixss() {
    if [ $# -lt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: nixss SEARCH"
    else
        s="$1"
        shift
        nix search --quiet nixpkgs "\.${s}$" 2>/dev/null | grep -v "warning:"
    fi
}
#        nixsi                   nix search installed packages
nixsi() {
    if [ $# -lt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: nixsi SEARCH"
    else
        nix-store --quiet -q --references /run/current-system/sw | grep -i "$*" | sort
    fi
}
#        nixsg                   nix search with grep
nixsg() {
    if [ $# -lt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: nixsg SEARCH GREP"
    else
        s="$1"
        shift
        tmpfile="$(mktemp)"
        nix search --quiet nixpkgs "${s}" 2>/dev/null | head -n -1 > "${tmpfile}"
        sed -n ":a ; /^\* / { N ; s/\n// ; p ; d ; ba }" "${tmpfile}" | grep -i "$*"
        rm "${tmpfile}"
    fi
}
#        nixfi                   nix locate package of installed file
nixfi() {
    if [ $# -lt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: nixfi FILE"
    else
        readlink -e $(which $@)
    fi
}

#
# qubes os
#
#        qd-copy-from-vm           copy something from a vm to dom0
qd-copy-from-vm() {
    if [ $# -lt 3 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] || [ "$(uname -n)" != "dom0" ] ; then
        echo "Usage: qd-copy-from-vm VM PATH FILE"
        echo "Can only be run on dom0"
    else
        qvm-run --pass-io "$1" "tar -C \"$2\" -c \"$3\"" | tar -x
    fi
}
#        qd-copy-to-vm             copy something from dom0 to a vm
qd-copy-to-vm() {
    if [ $# -lt 3 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] || [ "$(uname -n)" != "dom0" ] ; then
        echo "Usage: qd-copy-to-vm VM FILE PATH"
        echo "Can only be run on dom0"
    else
        tar -cf - "$2" | qvm-run --pass-io "$1" "tar -C \"$3\" -xf -"
    fi
}
#        qd-sync                   copy personal config to dom0
qd-sync() {
    if [ "$1" == "-h" ] || [ "$1" == "--help" ] || [ "$(uname -n)" != "dom0" ] ; then
        echo "Usage: qd-sync [OS]"
        echo "OS:"
        echo "  arch"
        echo "  debian"
        [ "$(uname -n)" != "dom0" ] && echo "Error: Can only be run on dom0"
    else
        rm -rf "${HOME}/config.old"
        mv -f "${HOME}/config" "${HOME}/config.old"
        qvm-run --pass-io personal 'tar -C /home/user -c --exclude=\".git*\" config' | tar -C "${HOME}" -x
        rm -rf "${HOME}/config-private.old"
        mv -f "${HOME}/config-private" "${HOME}/config-private.old"
        qvm-run --pass-io personal 'tar -C /home/user -c --exclude=\".git*\" config-private' | tar -C "${HOME}" -x
        sudo cp "${HOME}/config/config/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-keyboard-shortcuts.xml" \
            "/etc/xdg/xfce4/xfconf/xfce-perchannel-xml/"
        [ "$1" == "arch" ] && tar -C "${HOME}/config/config/.config" -cf - metapac-arch | qvm-run --pass-io arch 'tar -C "/home/user/.config" -xf -'
        [ "$1" == "debian" ] && tar -C "${HOME}/config/config/.config" -cf - metapac-debian | qvm-run --pass-io debian 'tar -C "/home/user/.config" -xf -'
        home-restow
    fi
}

#
# dvd encode
#
#        dvd-titles              list dvd titles
dvd-titles() {
    lsdvd /dev/dvd
}
#        dvd-encode              encode a dvd track
dvd-encode() {
    if [ $# -lt 1 ] || [ $# -gt 2 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: dvd-encode TRACK [FILE]"
    else
        track="$1"
        unshift
        if [ $# -eq 0 ] ; then
            file="dvdvideo.avi"
        else
            file="$1"
        fi
        # one pass encode
        mencoder "dvd://${track}" -ovc "lavc" -lavcopts vcodec="mpeg4:vhq:v4mv:vqmin=2:vbitrate=1800" \
                 -oac "mp3lame" -lameopts "abr:br=128" -o "${file}"
        # # two pass encode
        # # encode audio
        # mencoder dvd://${track} -ovc frameno -o ${file}.audio -oac mp3lame -lameopts abr:br=128
        # # encode video, first pass
        # mencoder dvd://${track} -audiofile ${file}.audio -oac copy -o /dev/null \
            #   -ovc lavc -lavcopts vcodec=mpeg4:vbitrate=1800:vhq:vpass=1:vqmin=2:vqmax=31
        # # encode video, second pass
        # mencoder dvd://${track} -audiofile ${file}.audio -oac copy -o ${file} \
            #   -ovc lavc -lavcopts vcodec=mpeg4:vbitrate=1800:vhq:vpass=2:vqmin=2:vqmax=31
    fi
}

#
# git
#
#        git-master              git master branch name
git-master() {
    git remote show origin | sed -n '/HEAD branch/s/.*: //p'
}
#        git-branch              git branch name
git-branch() {
    #git branch --no-color 2>/dev/null | sed -n '/^\*/s/^\* *//p'
    git rev-parse --abbrev-ref HEAD 2>/dev/null
}
#        git-branch-prompt       git branch name for terminal prompt
git-branch-prompt() {
    gitbranch=$(git-branch)
    if [ -z "${gitbranch}" ] ; then
        echo ""
    else
        echo "  ${gitbranch}"
    fi
}
#        gitcouo                 git checkout BRANCH and pull origin BRANCH
gitcouo() {
    if [ $# -lt 1 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: gitcouo BRANCH"
        echo "  BRANCH  branch to checkout and pull"
    else
        branch="$1"
        git checkout "${branch}" && git pull origin "${branch}"
    fi
}
#        _gitsync                pull, commit, and push given home git repositories
_gitsync() {
    for dir in "$@" ; do
        if [ -d "${HOME}/${dir}" ] ; then
            # remove org font files
            echo "Removing org font files..."
            find "${HOME}/${dir}" -name '*org-src-fontification*' -print0 | \
                xargs -0 rm >/dev/null 2>&1

            # pull (update) home git repository (from origin)
            echo "Pulling '${dir}' from origin..."
            (cd "${HOME}/${dir}" && git pull origin)

            check=$(cd "${HOME}/${dir}" && git config --get remote.origin.url | grep "^git@")
            if [ -n "${check}" ] ; then
                # commit (check in) home git repositories (default update)
                echo "Committing '${dir}'..."
                (cd "${HOME}/${dir}" && git commit -a -m "Update")

                # push home git repositories (to origin)
                echo "Pushing '${dir}' to origin..."
                (cd "${HOME}/${dir}" && git push origin)
            fi
        fi
    done
}
#        git-sync-config         pull, commit, and push config git repositories
git-sync-config() {
    # output datetime
    date '+%Y-%m-%d %H:%M:%S'
    hn="$(uname -n)"

    if [ -d "$(configdir)" ] ; then
        # only update xscreensaver preferences on tank or dozer
        if [ -f "${HOME}/.xscreensaver" ] && [ ! -L "${HOME}/.xscreensaver" ] ; then
            if [ "${hn}" == "tank" ] || [ "${hn}" == "personal" ] || [ "${hn}" == "dozer" ] ; then
                echo "Update .xscreensaver..."
                (
                    cd "${HOME}" && \
                        cp ".xscreensaver" "$(configdir)/common/" && \
                        ln -sf "$(configdir)/common/.xscreensaver" .
                )
            fi
        fi
    fi

    if [ -d "$(configdir)-private" ] ; then
        #if [ -L ".cron" ] && [ -f "config-private/custom/$(uname -n)/.cron" ] ; then
        #    echo "Update crontab..."
        #    crontab -l > "config-private/custom/$(uname -n)/.cron"
        #fi
        # update addressbook
        if [ -f "${HOME}/.addressbook" ] && [ ! -L "${HOME}/.addressbook" ] ; then
            echo "Update .addressbook..."
            (
                cd "${HOME}" && \
                    cp ".addressbook" "$(configdir)-private/common/" && \
                    ln -sf "$(configdir)-private/common/.addressbook" .
            )
        fi
    fi

    # sync config repositories
    _gitsync "config" "config-private"
}
#        git-sync-extra          pull, commit, and push extra home git repositories
git-sync-extra() {
    # output datetime
    date '+%Y-%m-%d %H:%M:%S'

    # sync extra repositories
    _gitsync "dev" "doc" "web"
}
#        git-sync-home           pull, commit, and push all home git repositories
git-sync-home() {
    # sync all home repositories
    git-sync-config
    echo
    git-sync-extra
}

#
# backup / copy
#
#        backup-files            backup a file or directory to /home/backup
backup-files() {
    if [ $# -lt 2 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: backup-files PREFIX FILE..."
    else
        # get parameters
        pre="$1"
        shift
        arch="${pre}_$(date +'%Y-%m-%d_%H%M%S').tgz"
        # create gziped tar backup file
        tar -cvzplf "${arch}" "$@"
        # move backup file to backup directory
        mkdir -p "/home/backup/${pre}"
        mv "${arch}" "/home/backup/${pre}"
    fi
}
#        rsync-bundle            generate encrypted bundle and rsync it to mounted ventoy usb
rsync-bundle() {
    # check destination
    dest="/run/media/${USER}/FILES"
    if [ ! -d "${dest}" ] ; then
        echo "Could not find mounted USB at '${dest}'"
        return 1
    fi

    # create bundle
    root="/tmp/bundle-$$"
    tmp="${root}/bundle"
    mkdir -p "${tmp}"
    # add ~/.ssh
    mkdir -p "${tmp}/.ssh" && chmod 700 "${tmp}/.ssh"
    cp -p "${HOME}/.ssh/id_"* "${tmp}/.ssh/"
    # # add make-etc-hosts
    # cp "${HOME}/bin/make-etc-hosts" "${tmp}/"
    # package and encrypt bundle directory
    pushd "${root}"
    tar -cvfz "bundle.tgz" "bundle"
    #ccrypt -e "bundle.tgz"
    openssl enc -e -aes-256-cbc -md sha512 -pbkdf2 -iter 100000 -salt -in "bundle.tgz" -out "bundle.tgz.enc"
    # sync bundle to usb
    rsync -rLtxc --progress --delete "bundle.tgz.enc" "${dest}/"
    # add decrypt script
    echo "openssl enc -d -aes-256-cbc -md sha512 -pbkdf2 -iter 100000 -salt -in bundle.tgz.enc -out bundle.tgz" > "${dest}/bundle-decrypt"
    chmod +x "${dest}/bundle-decrypt"
    popd
    rm -rf "${root}"
}
#        rsync-cruzer            rsync ISOs and bundle to sandisk cruzer
rsync-cruzer() {
    # check destination
    dest="/run/media/${USER}/Ventoy"
    if [ ! -d ${dest} ] ; then
        echo "Could not find mounted USB at ${dest}"
        return 1
    fi

    # sync ISOs
    root="/home/data/media/Software/Boot Tools"
    files=(
        "${root}/Clonezilla Live "*.iso
        "${root}/Darik's Boot and Nuke "*.iso
        "${root}/GParted Live "*.iso
        "${root}/MasterBooter "*.iso
        "${root}/Plop Boot Manager.iso"
        "${root}/Super Grub2 "*.iso
        "${root}/System Rescue "*.iso
    )
    for file in "${files[@]}" ; do
        #rsynW -rLtxc --progress --delete "${file}" "${dest}/"
        rsynW -rLtxW --size-only --progress --delete "${file}" "${dest}/"
    done

    # create and copy bundle
    rsync-bundle
}
#        rsync-install           rsync software ISOs to mounted ventoy usb
rsync-install() {
    root="/home/data/media/Software"
    dest="/run/media/${USER}/Ventoy"
    syncdir() {
        local sdir="$1"
        local ddir="$2"
        local query="$3"
        mkdir -p "${dest}/${ddir}"
        (
            cd "${root}/${sdir}" && \
                find . -mindepth 1 -maxdepth 1 -name "${query}" -printf '%P\n' | while read -r src ; do
                    #dst=$(echo "${src}" | sed "s/ /-/g")
                    dst="${src// /-}"
                    echo "Syncing \"${root}/${sdir}/${src}\" \"${dest}/${ddir}/${dst}\""
                    #rsync -rLtxc "${root}/${sdir}/${src}" "${dest}/${ddir}/${dst}"
                    rsync -rLtxW --size-only --progress "${root}/${sdir}/${src}" "${dest}/${ddir}/${dst}"
                done
        )
    }

    syncdir 'Boot Tools' 'Boot-Tools' '*.iso'
    syncdir 'DOSBox/DOSBox' 'DOS' '*.iso'
    #syncdir 'Haiku/Haiku OS' 'Haiku' 'Haiku-R1-Beta4-*.iso' # Haiku does not work with Ventoy
    syncdir 'Hypervisor/OpenIndiana' 'Hypervisor' '*.iso'
    syncdir 'Hypervisor/SmartOS' 'Hypervisor' '*.iso'
    syncdir 'Hypervisor/VMware ESXi (vSphere Hypervisor)' 'Hypervisor' '*.iso'
    syncdir 'Hypervisor/XCP NG' 'Hypervisor' '*.iso'
    syncdir 'Linux/Linux OS' 'Linux' '*.iso'
    syncdir 'OS2/ArcaOS/ArcaOS-5.0.5' 'Other' '*.iso'
    syncdir 'Windows XP, 7, 10/Windows OS' 'Windows' '*.iso'
    sync
}
#        rsync-iodd              rsync software ISOs to mounted iodd drive
rsync-iodd() {
    root="/home/data/media/Software"
    dest="/run/media/${USER}/iodd"
    syncdir() {
        local sdir="$1"
        local ddir="$2"
        local query="$3"
        mkdir -p "${dest}/${ddir}"
        (
            cd "${root}/${sdir}" && \
                find . -mindepth 1 -maxdepth 1 -name "${query}" -printf '%P\n' | while read -r src ; do
                    #dst=$(echo "${src}" | sed "s/ /-/g")
                    dst="${src// /-}"
                    echo "Syncing \"${root}/${sdir}/${src}\" \"${dest}/${ddir}/${dst}\""
                    #rsync -rLtxc "${root}/${sdir}/${src}" "${dest}/${ddir}/${dst}"
                    rsync -rLtxW --size-only --progress "${root}/${sdir}/${src}" "${dest}/${ddir}/${dst}"
                done
        )
    }

    syncdir 'Amiga/Amiga Forever' 'Amiga' '*.iso'
    syncdir 'Amiga/Icaros' 'Amiga' '*.iso'
    syncdir 'Amiga/Amiga OS' 'Amiga' '*.iso'
    syncdir 'Android/Android x86' 'Android' '*.iso'
    syncdir 'Boot Tools' 'Boot-Tools' '*.iso'
    syncdir 'BSD' 'BSD' '*.iso'
    syncdir 'DOSBox/DOSBox' 'DOS' '*.iso'
    syncdir 'FreeDOS/FreeDOS 1.3 Live CD' 'FreeDOS' '*.iso'
    syncdir 'Haiku/Haiku OS' 'Haiku' '*.iso'
    syncdir 'Hypervisor/OpenIndiana' 'Hypervisor' '*.iso'
    syncdir 'Hypervisor/SmartOS' 'Hypervisor' '*.iso'
    syncdir 'Hypervisor/VMware ESXi (vSphere Hypervisor)' 'Hypervisor' '*.iso'
    syncdir 'Hypervisor/XCP NG' 'Hypervisor' '*.iso'
    syncdir 'Linux/Linux OS' 'Linux' '*.iso'
    syncdir 'Linux/Qubes OS' 'Linux' '*.iso'
    syncdir 'Linux/Legacy/Debian 1.3' 'Linux (Legacy)/Debian' '*.iso'
    syncdir 'Linux/Legacy/Debian 2.0' 'Linux (Legacy)/Debian' '*.iso'
    syncdir 'Linux/Legacy/Debian 2.1' 'Linux (Legacy)/Debian' '*.iso'
    syncdir 'Linux/Legacy/PiTuX (Micro Serial Terminal Linux)' 'Linux (Legacy)/PiTuX (Micro Serial Terminal Linux)' '*.iso'
    syncdir 'Linux/Legacy/TinyCore' 'Linux (Legacy)/TinyCore' '*.iso'
    syncdir 'Macintosh/Macintosh OS/Macintosh OS 9 (PPC)' 'Macintosh/Macintosh OS 9 (PPC)' '*.iso'
    syncdir 'Macintosh/Macintosh OS/Macintosh OS X' 'Macintosh/Macintosh OS X' '*.iso'
    syncdir 'NextStep' 'NextStep/OpenStep OS' '*.iso'
    syncdir 'OS2/ArcaOS/ArcaOS-5.0.5' 'Other' '*.iso'
    syncdir 'ReactOS' 'ReactOS' '*.iso'
    syncdir 'Windows XP, 7, 10/Windows OS' 'Windows' '*.iso'
    syncdir 'Windows XP, 7, 10/Windows OS/Windows XP Delta Edition' 'Windows/Windows XP Delta' '*.iso'
    syncdir 'Windows XP, 7, 10/Windows OS/Windows XP Epsilon Edition' 'Windows/Windows XP Epsilon' '*.iso'
    sync
}

#
# java
#
#        jar-version             display java version used to build jars
jar-version() {
    if [ $# -gt 2 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: jar-version [DIR [PATTERN]]"
        echo "Display Java version used to build jar files in DIR matching PATTERN."
        echo "  DIR      defaults to '.'"
        echo "  PATTERN  defaults to '*.jar'"
    else
        dir="$1"
        [ -z "${dir}" ] && dir="."
        pattern="$2"
        [ -z "${pattern}" ] && pattern="*.jar"
        tmpdir="$(mktemp -d)"
        find "${dir}" -name "${pattern}" -type f | while read -r jar ; do
            mkdir -p "${tmpdir}"
            cp "${jar}" "${tmpdir}/"
            (
                cd "${tmpdir}" && \
                    unzip "${jar}" >/dev/null && \
                    echo "${jar} $(grep '^Created-By' 'META-INF/MANIFEST.MF' | sed 's/^Created-By: // ; s/ (Sun.*$//')"
            )
            rm -rf "${tmpdir}"
        done | column --table
    fi
}

#
# android
#
#        adb-log-app             show adb log for specific app
adb-log-app() {
    if [ $# -lt 1 ] || [ $# -gt 2 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ] ; then
        echo "Usage: adb-log-app [PARAMS] PACKAGE"
        echo "Dump the ADB log for a specific PACKAGE."
        echo "Optional PARAMS can be any ADB params, such as:"
        echo "  -e         emulator"
        echo "  -d         device"
        echo "  -s DEVICE  specific device"
    elif [ $# -eq 1 ] ; then
        adb logcat | grep $(adb shell ps | grep "$1" | cut -c10-15)
    else
        adb ${*:1:$#-1} logcat | grep $(adb ${*:1:$#-1} shell ps | grep "${*: -1}" | cut -c10-15)
    fi
}

#
# setup
#
#        home-howto              howto setup git home dir on a new machine
home-howto() {
    cat <<EOF
Install packages: base-devel stow

Copy ~/.ssh directory from existing machine:
  scp -r ~/.ssh USER@HOSTNAME:/home/USER/

Or copy bundle.tgz.enc from USB, decrypt it, and run scripts:
  mkdir -p ~/tmp && cd ~/tmp
  cp /media/FILES/bundle* .
  chmod +x ./bundle-decrypt && ./bundle-decrypt
  tar -xzf bundle.tgz
  mv bundle/.ssh ~/

Checkout config and config-private:
  git clone ${GIT_REPOSITORY_CONFIG} ~/config
  git clone ${GIT_REPOSITORY_CONFIG_PRIVATE} ~/config-private

Source environment scripts:
  source ~/config/common/.funct
  source ~/config/common/.alias
  source ~/config/common/.shellrc

Checkout doc repository:
  gitcodoc

Checkout dev repository:
  gitcodev

Checkout web repository:
  gitcoweb

Create the initial links from ~ to ~/config and ~/config-private:
  home-initialize
(Run 'home-restow' to recreate the links in the future.)

Copy wallpapers:
  copy-wallpapers

Setup /home/data directory:
  sudo mkdir -p /home/data && sudo chown \${USER}:\${USER} /home/data
EOF
}
#        home-initialize         stow links from ~/ to ~/config and ~/config-private dirs
home-initialize() {
    backupdir="${HOME}/original-configuration-files-$(date +'%Y%m%d')"
    backupfiles=(
        ".bash_logout"
        ".bash_profile"
        ".bashrc"
        ".i3"
        ".profile"
        ".xinitrc"
        ".xprofile"
        ".Xresources"
        ".zshrc"
    )
    symlinkdirs=(
        "/home/data/media/Audio/Sounds"
        "/home/data/media/Repos/C64"
        "/home/data/media/Repos/DOS"
    )

    echo "You are about to setup links from '${HOME}' to '$(configdir)' and '$(configdir)-private'."
    echo "All files and directories replaced will be moved to '${backupdir}'."
    echo "This command should only be run once for a given HOME directory."
    [ -e "${HOME}/.alias" ] && echo "It looks like stow initialization has already occurred" && return 1
    echo -n "Do you wish to proceed? [yN] " ; read -r a

    case "${a}" in
        y|Y)
            [ -d "$(configdir)" ] || (echo "Missing config directory!" && return 1)

            echo "Moving existing home files to '${backupdir}'..."
            (
                cd "${HOME}" && \
                    mkdir -p "${backupdir}" && \
                    for file in "${backupfiles[@]}" ; do
                        if [ -e "${file}" ] ; then
                            echo "  ${file} ==> ${backupdir}"
                            mv "${file}" "${backupdir}/"
                        fi
                    done
            ) || (echo "Errors encountered while backing up existing files!" && return 1)

            # create stow target directories
            echo "Creating stow target directories..."
            mkdir -p "${HOME}/.emacs.d"
            mkdir -p "${HOME}/.local/share/applications"
            find "$(configdir)/config/.config" -mindepth 1 -maxdepth 1 -type d | \
                while read -r dir ; do
                    bn=$(basename "${dir}")
                    mkdir -p "${HOME}/.config/${bn}"
                done

            # stow
            echo "Stowing packages..."
            (cd "${HOME}" && ln -s -f config/.stow-global-ignore .)
            stow --dir="$(configdir)" --target="${HOME}" --stow "common" "emacs"
            stow --dir="$(configdir)" --target="${HOME}" --no-folding --stow "config" "local"
            stow --dir="$(configdir)/custom" --target="${HOME}" --no-folding --stow "$(uname -n)"
            [ -d "$(configdir)-private" ] && stow --dir="$(configdir)-private" --target="${HOME}" --stow "common" "emacs"
            [ -d "$(configdir)-private" ] && stow --dir="$(configdir)-private" --target="${HOME}" --no-folding --stow "config"

            echo "Making other symlinks..."
            (
                cd "${HOME}" && \
                    for file in "${symlinkdirs[@]}" ; do
                        if [ -d "${file}" ] ; then
                            echo "  ${file}"
                            ln -sf "${file}" .
                        fi
                    done
            )
            ;;
    esac
}
#        home-restow             restow links from ~/ to ~/config and ~/config-private dirs
home-restow() {
    # create stow target directories
    echo "Creating stow target directories..."
    mkdir -p "${HOME}/.emacs.d"
    mkdir -p "${HOME}/.local/share/applications"
    find "$(configdir)/config/.config" -mindepth 1 -type d | \
        while read -r dir ; do
            bn=$(basename "${dir}")
            mkdir -p "${HOME}/.config/${bn}"
        done

    # cleanup
    echo "Cleanup some files..."
    for file in "gtk-3.0/bookmarks" \
                    "gtk-3.0/gtk.css" \
                    "gtk-3.0/settings.ini" \
                    "gtk-4.0/settings.ini" \
                    "xfce4/xfconf/xfce-perchannel-xml/keyboards.xml" \
                    "xfce4/xfconf/xfce-perchannel-xml/xfce4-keyboard-shortcuts.xml" \
                    "xfce4/xfconf/xfce-perchannel-xml/xfce4-power-manager.xml" \
                    "xfce4/xfconf/xfce-perchannel-xml/xfce4-session.xml" \
                    "xfce4/xfconf/xfce-perchannel-xml/xsettings.xml"
    do
        if [ -f "${HOME}/.config/${file}" ] && [ ! -L "${HOME}/.config/${file}" ] ; then
            mv "${HOME}/.config/${file}" "${HOME}/.config/${file}.old"
        fi
    done

    # restow
    echo "Restowing packages..."
    (cd "${HOME}" && ln -s -f config/.stow-global-ignore .)
    stow --dir="$(configdir)" --target="${HOME}" --restow "common" "emacs"
    stow --dir="$(configdir)" --target="${HOME}" --no-folding --restow "config" "local"
    stow --dir="$(configdir)/custom" --target="${HOME}" --no-folding --restow "$(uname -n)"
    [ -d "$(configdir)-private" ] && stow --dir="$(configdir)-private" --target="${HOME}" --restow "common" "emacs"
    [ -d "$(configdir)-private" ] && stow --dir="$(configdir)-private" --target="${HOME}" --no-folding --restow "config" "local"
}
#        make-metapac-groups  generate metapac package groups
make-metapac-groups() {
    infile="${HOME}/org/personal.org"

    _getregexp() {
        printf "/^[ \t]*#\+NAME: %s-packages\$/,/^\*/{print \$0}" "$1"
    }

    _getgroups() {
        awk "$(_getregexp "$1")" "${infile}" | tail -n +4 | head -n -1 | \
            grep -v "^ *|---" | grep -v "^ *| *x *|" | \
            cut -d '|' -f 3 | sort --unique | sed 's/^ *// ; s/ *$//'
    }

    _getpackages() {
        awk "$(_getregexp "$1")" "${infile}" | tail -n +4 | head -n -1 | \
            grep "^ *| *| $2 *|" | \
            grep -v "^ *|---" | grep -v "^ *| *x *|" | \
            cut -d '|' -f 4 | sed 's/^ */    \"/ ; s/ *$/\",/'
    }

    for backend in "apt" "arch" ; do
        outdir="${HOME}/config/config/.config/metapac-${backend}/groups"
        mkdir -p "${outdir}"
        for group in $(_getgroups ${backend}) ; do
            printf "" > "${outdir}/${group}.toml"
            printf "%s\n%s\n%s\n\n" \
                   "${backend} = [" \
                   "$(_getpackages ${backend} "${group}")" \
                   "]" \
                   >> "${outdir}/${group}.toml"
        done
    done
}
#        ollama-model-install  install ollama models
ollama-model-install() {
    awk "/^[ \t]*#\+NAME: ollama-models\$/,/^\*/{print \$0}" \
        "${HOME}/org/personal.org" | \
        sed -n 's/^ *// ; s/ *#.*$// ; /^ollama pull/p' | \
        while read -r cmd ; do
            echo "${cmd}"
            eval "${cmd}"
        done
}
#        arch-initialize      setup arch system
arch-initialize() {
    _getsection() {
        local file="${HOME}/org/personal.org"
        local regexp="/^[ \t]*#\+NAME: $1\$/,/^[ \t]*#\+END_SRC\$/{print \$0}"
        awk "${regexp}" "${file}" | tail -n +3 | head -n -1 | sed 's/^[ \t]*//' | \
            sed 's/--needed/--needed --answerdiff None --answerclean None --mflags \"--noconfirm\"/' | \
            sed 's/yay /yes | yay /'
    }

    initial=(
        "arch-group"
        "arch-sudoers"
        "arch-sysctl-conf"
        "arch-systemd"
        #"arch-locale"
        "arch-package-managers"
    )

    standard=(
        #"arch-lightdm-conf"
        "arch-lightdm-gtk-greeter-conf"
        #"arch-lightdm-slick-greeter-conf"
        "arch-pkgfile"
        "arch-copy-wallpapers"
        "arch-fix-backgrounds"
        #"arch-set-background-image"
        "arch-fonts"
        "arch-ssh-config"
        "arch-networkmanager"
        #"arch-configure-audacious"
        #"arch-configure-gsync"
        #"arch-configure-irssi"
        #"arch-configure-java-8-openjdk"
        #"arch-configure-java-11-openjdk"
        #"arch-configure-tlp"
        #"arch-configure-x48"
        "arch-configure-xscreensaver-aerial"
        "arch-bluetooth-audio"
        "arch-printer-cannon"
        #"arch-capslock-control"
        "arch-capslock-control-terminal"
        "arch-capslock-control-x11"
        "arch-services"
        "arch-user-services"
        "arch-final"
    )

    sections=(${initial[@]} ${standard[@]})

    if [ "$(distribution)" != "arch" ] ; then
        echo "Not running Arch"
        return 1
    fi

    echo
    echo "========== Arch Initialization Script =========="
    echo

    for section in ${sections[@]} ; do
        echo
        echo "========== ${section} =========="
        echo
        #echo "$(_getsection ${section})"
        eval "$(_getsection ${section})"
    done

    echo
    echo "========== Arch Initialization Complete =========="
    echo
}

#!
#!==============================================================================
#! End of File
#!==============================================================================
